package sort

// 平均时间复杂度: O(Nlog2N)
// 最差时间复杂度: O(N^2)
// 空间复杂度: O(1)
// 稳定性: 不稳定
// 复杂性: 较复杂

// 希尔排序的效率取决于增量值gap的选取, 时间复杂度并不是一个定值
// 开始时, gap取值较大, 子序列中的元素较少, 排序速度快, 克服了直接插入排序的缺点;
// 其次, gap值逐渐变小后, 虽然子序列的元素逐渐变多, 但大多元素已基本有序,
// 所以继承了直接插入排序的优点, 能以近线性的速度排好序
// 最优的空间复杂度为开始元素已排序, 则空间复杂度为 0;
// 最差的空间复杂度为开始元素为逆排序, 则空间复杂度为 O(N);
// 平均的空间复杂度为O(1), 希尔排序并不只是相邻元素的比较, 有许多跳跃式的比较,
// 难免会出现相同元素之间的相对位置发生变化, 所以希尔排序是不稳定的算法

// 先将整个待排元素序列分割成若干个子序列(由相隔某个“增量”的元素组成的)分别进行直接插入排序
// 然后依次缩减增量再进行排序, 待整个序列中的元素基本有序(增量足够小)时, 再对全体元素进行一
// 次直接插入排序

// ShellSort ...
func ShellSort(array []int) {
	n := len(array)
	if n <= 1 {
		return
	}

	for gap := n / 2; gap > 0; gap = gap / 2 {
		for i := gap; i < n; i++ {
			cur := array[i]
			j := i - gap
			for ; j >= 0; j -= gap {
				if array[j] > cur {
					array[j+gap] = array[j]
				} else {
					break
				}
			}

			array[j+gap] = cur
		}
	}
}
