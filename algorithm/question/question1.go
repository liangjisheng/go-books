package main

// 题目描述: 在一个长度为n的数组里的所有数字都在0到n-1的范围内. 数组中某些数字是重复的
// 但不知道有几个数字是重复的. 也不知道每个数字重复几次. 请找出数组中任意一个重复的数字
// 例如, 如果输入长度为7的数组{2,3,1,0,2,5,3}, 那么2和3就是重复的数字了, 那么可以随意
// 返回2或者返回3都可以了, 任意选择一个即可.

// 解法1: 给数组排序下, 然后从左到右遍历, 看看有相邻的数有没有相等即可.
// 时间复杂度是 O(nlogn), 空间复杂度O(1)

// 解法2: 用一个哈希表来存放这些数组, 把数组元素值作为 key, 相同元素的个数作为 value
// 遍历的过程中, 只要发现某个 key 的 value 超过 1, 那么这个数就是重复的了, 直接返回
// 时间复杂度是 O(n), 空间复杂度是 O(n).

// 解法3: 更好的解法是时间复杂度是 O(n),空间复杂度是 O(1)
// 由于数字的范围是 0-n-1, 那么我们可以这样做: 从左到右遍历数组arr, 对于 arr[i],
// 我们可以把arr[i]放到数组下标为arr[i]的位置上, 即arr[arr[i]] = arr[i].例如 arr[0] = 4
// 那么我们就把arr[0]与arr[4]进行交换. 假如数组中没有重复的数, 那么遍历完成后的结果是
// arr[i] = i. 如果数组有重复的元素, 那么当我们要把 arr[i] 与 arr[arr[i]] 进行交换的时候
// 会发现 arr[arr[i]] 的值已经为arr[i]了, 并且arr[i] != i.

// 例如数组为 arr = {2, 3, 3, 0} 步骤如下
// 1、从左到右遍历, 此时数组下标i = 0, 即arr[i] = 2. 把 arr[0] 与 arr[2] 进行交换,
// 交换的结果为 arr = [3, 3, 2, 0}
// 2、i = 0,由于 arr[0] = 3, 不满足 arr[i] = i,所以我们的下标还是不能右移, 还是得继续交换
// 即把 arr[0] 与 arr[3] 进行交换, 结果为 arr[0, 3, 2, 3}.
// 3、i = 0,此时 arr[i] = i. 故下标右移, 即 令 i = 1. 此时 arr[i] = arr[1] = 3.
// 把arr[1] 和 arr[3] 进行交换, 但是这时候 arr[3] = 3.即此时出现了
// arr[arr[1]] = arr[3]并且 arr[i] != i 的情况, 故出现了重复的元素了,
// 直接把 3 返回, 遍历结束

func duplicate(array []int) int {
	n := len(array)
	i := 0
	for i < n {
		// 索引i对应的数组元素与索引为 array[i] 对应的数组元素不相等: 交换
		// 是的索引为 array[i] 的位置存放的元素是 array[i]
		if array[array[i]] != array[i] {
			tmp := array[array[i]]
			array[array[i]] = array[i]
			array[i] = tmp
		} else {
			// 如果相等的话, 分2种情况
			// 1. i 和 array[i] 相等的话,说明 i 索引出存放的元素就是i: i加1
			// 2. i 和 array[i] 不等的话,说明 i 索引和 array[i] 索引存放的元素相等即重复
			if i == array[i] {
				i++
			} else {
				return array[i]
			}
		}
	}
	return -1
}
